{
  "record-forwarding-github": "#[cfg(all(feature = \"proxy\", feature = \"record\"))]\n#[test]\nfn record_github_api_with_forwarding_test() {\n    // Let's create our mock server for the test\n    let server = MockServer::start();\n\n    // We configure our server to forward the request to the target\n    // host instead of answering with a mocked response. The 'when'\n    // variable lets you configure rules under which forwarding\n    // should take place.\n    server.forward_to(\"https://api.github.com\", |rule| {\n        rule.filter(|when| {\n            when.any_request(); // Ensure all requests are forwarded.\n        });\n    });\n\n    let recording = server.record(|rule| {\n        rule\n            // Specify which headers to record.\n            // Only the headers listed here will be captured and stored\n            // as part of the recorded mock. This selective recording is\n            // necessary because some headers may vary between requests\n            // and could cause issues when replaying the mock later.\n            // For instance, headers like 'Authorization' or 'Date' may\n            // change with each request.\n            .record_request_header(\"User-Agent\")\n            .filter(|when| {\n                when.any_request(); // Ensure all requests are recorded.\n            });\n    });\n\n    // Now let's send an HTTP request to the mock server. The request\n    // will be forwarded to the GitHub API, as we configured before.\n    let client = Client::new();\n\n    let response = client\n        .get(server.url(\"/repos/torvalds/linux\"))\n        // GitHub requires us to send a user agent header\n        .header(\"User-Agent\", \"httpmock-test\")\n        .send()\n        .unwrap();\n\n    // Since the request was forwarded, we should see a GitHub API response.\n    assert_eq!(response.status().as_u16(), 200);\n    assert_eq!(true, response.text().unwrap().contains(\"\\\"private\\\":false\"));\n\n    // Save the recording to\n    // \"target/httpmock/recordings/github-torvalds-scenario_<timestamp>.yaml\".\n    recording\n        .save(\"github-torvalds-scenario\")\n        .expect(\"cannot store scenario on disk\");\n}",
  "record-proxy-github": "#[cfg(all(feature = \"proxy\", feature = \"record\", feature = \"experimental\"))]\n#[test]\nfn record_with_proxy_test() {\n    // Start a mock server to act as a proxy for the HTTP client\n    let server = MockServer::start();\n\n    // Configure the mock server to proxy all incoming requests\n    server.proxy(|rule| {\n        rule.filter(|when| {\n            when.any_request(); // Intercept all requests\n        });\n    });\n\n    // Set up recording on the mock server to capture all proxied\n    // requests and responses\n    let recording = server.record(|rule| {\n        rule.filter(|when| {\n            when.any_request(); // Record all requests\n        });\n    });\n\n    // Create an HTTP client configured to route requests\n    // through the mock proxy server\n    let github_client = Client::builder()\n        // Set the proxy URL to the mock server's URL\n        .proxy(reqwest::Proxy::all(server.base_url()).unwrap())\n        .build()\n        .unwrap();\n\n    // Send a GET request using the client, which will be proxied by the mock server\n    let response = github_client.get(server.base_url()).send().unwrap();\n\n    // Verify that the response matches the expected mock response\n    assert_eq!(response.text().unwrap(), \"This is a mock response\");\n\n    // Save the recorded HTTP interactions to a file for future reference or testing\n    recording\n        .save(\"my_scenario_name\")\n        .expect(\"could not save the recording\");\n}",
  "forwarding-github": "#[cfg(feature = \"proxy\")]\n#[test]\nfn forward_to_github_test() {\n    // Let's create our mock server for the test\n    let server = MockServer::start();\n\n    // We configure our server to forward the request to the target\n    // host instead of answering with a mocked response. The 'when'\n    // variable lets you configure rules under which forwarding\n    // should take place.\n    server.forward_to(\"https://api.github.com\", |rule| {\n        rule.filter(|when| {\n            when.any_request(); // Ensure all requests are forwarded.\n        });\n    });\n\n    // Now let's send an HTTP request to the mock server. The request\n    // will be forwarded to the GitHub API, as we configured before.\n    let client = Client::new();\n\n    let response = client\n        .get(server.url(\"/repos/torvalds/linux\"))\n        // GitHub requires us to send a user agent header\n        .header(\"User-Agent\", \"httpmock-test\")\n        .send()\n        .unwrap();\n\n    // Since the request was forwarded, we should see a GitHub API response.\n    assert_eq!(response.status().as_u16(), 200);\n    assert_eq!(true, response.text().unwrap().contains(\"\\\"private\\\":false\"));\n}",
  "forwarding": "#[cfg(feature = \"proxy\")]\n#[test]\nfn forwarding_test() {\n    // We will create this mock server to simulate a real service (e.g., GitHub, AWS, etc.).\n    let target_server = MockServer::start();\n    target_server.mock(|when, then| {\n        when.any_request();\n        then.status(200).body(\"Hi from fake GitHub!\");\n    });\n\n    // Let's create our mock server for the test\n    let server = MockServer::start();\n\n    // We configure our server to forward the request to the target host instead of\n    // answering with a mocked response. The 'when' variable lets you configure\n    // rules under which forwarding should take place.\n    server.forward_to(target_server.base_url(), |rule| {\n        rule.filter(|when| {\n            when.any_request(); // We want all requests to be forwarded.\n        });\n    });\n\n    // Now let's send an HTTP request to the mock server. The request will be forwarded\n    // to the target host, as we configured before.\n    let client = Client::new();\n\n    // Since the request was forwarded, we should see the target host's response.\n    let response = client.get(server.url(\"/get\")).send().unwrap();\n    assert_eq!(response.status().as_u16(), 200);\n    assert_eq!(response.text().unwrap(), \"Hi from fake GitHub!\");\n}",
  "playback-forwarding-github": "#[cfg(all(feature = \"proxy\", feature = \"record\"))]\n#[test]\nfn playback_github_api() {\n    // Start a mock server for the test\n    let server = MockServer::start();\n\n    // Configure the mock server to forward requests to the target\n    // host (GitHub API) instead of responding with a mock. The 'rule'\n    // parameter allows you to define conditions under which forwarding\n    // should occur.\n    server.forward_to(\"https://api.github.com\", |rule| {\n        rule.filter(|when| {\n            when.any_request(); // Forward all requests.\n        });\n    });\n\n    // Set up recording to capture all forwarded requests and responses\n    let recording = server.record(|rule| {\n        rule.filter(|when| {\n            when.any_request(); // Record all requests and responses.\n        });\n    });\n\n    // Send an HTTP request to the mock server, which will be forwarded\n    // to the GitHub API\n    let client = Client::new();\n    let response = client\n        .get(server.url(\"/repos/torvalds/linux\"))\n        // GitHub requires a User-Agent header\n        .header(\"User-Agent\", \"httpmock-test\")\n        .send()\n        .unwrap();\n\n    // Assert that the response from the forwarded request is as expected\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response.text().unwrap().contains(\"\\\"private\\\":false\"));\n\n    // Save the recorded interactions to a file\n    let target_path = recording\n        .save(\"github-torvalds-scenario\")\n        .expect(\"Failed to save the recording to disk\");\n\n    // Start a new mock server instance for playback\n    let playback_server = MockServer::start();\n\n    // Load the recorded interactions into the new mock server\n    playback_server.playback(target_path);\n\n    // Send a request to the playback server and verify the response\n    // matches the recorded data\n    let response = client\n        .get(playback_server.url(\"/repos/torvalds/linux\"))\n        .send()\n        .unwrap();\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response.text().unwrap().contains(\"\\\"private\\\":false\"));\n}"
}